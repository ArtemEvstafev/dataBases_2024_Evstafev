### hmw_analyze
Задача заключается в тестировании приозводительности базы данных с autovacuum (автоматическим переанализированием) и без.

#### **Теория**
**Autovacuum** — это встроенный механизм PostgreSQL, который автоматически выполняет обслуживание таблиц в базе данных.
Он предназначен для поддержания производительности системы, очищая мертвые строки и обновляя статистику. Когда строки обновляются или удаляются,
PostgreSQL не удаляет их физически, а помечает как "мертвые". autovacuum удаляет эти мертвые строки, освобождая место в таблице. Собирает статистику
таблиц (ANALYZE), чтобы планировщик запросов мог строить оптимальные планы выполнения. Замораживает старые идентификаторы транзакций (XID),
чтобы избежать их переполнения (что может привести к отказу системы).

Влияние autovacuum на **execution time**: удаление мертвых строк уменьшает объем данных, которые необходимо читать запросам.
Это снижает время выполнения запросов. Актуальная статистика позволяет планировщику строить оптимальные планы выполнения запросов,
что улучшает производительность.

Однако во время работы autovacuum потребляет ресурсы (CPU и память), что может увеличивать время выполнения других запросов. 
Особенно заметно на системах с интенсивной нагрузкой, когда запросы пользователей конкурируют за ресурсы с autovacuum.

#### **Методика**
В скрипте создаётся и заполняется тестовыми данными таблица. Выполняется замер общего времени выполнения запроса с помощью EXPLAIN ANALYZE. 
Отключается autovacuum, изменяются данные без изменения объема и снова ANALYZE. Выполнение стало медленнее почти в 2 раза(увеличилось с 4.5 до 9.3), так как
планировщик запросов стал использовать устаревшую информацию о распределении данных.

## **hmw_bench**
Задача заключается в тестировании приозводительности базы данных с помощью утилиты pgbench при различных значениях размера кэша.

#### **Теория**
**shared_buffers** — это параметр конфигурации PostgreSQL, который определяет объем памяти, выделенной сервером PostgreSQL для кэширования данных таблиц.
Это первый уровень кэша, используемый PostgreSQL, прежде чем обращаться к операционной системе или физическому диску. 
Когда данные запрашиваются из таблицы, PostgreSQL сначала проверяет, находятся ли они в shared_buffers. Если данные есть в этом кэше (cache hit),
они немедленно извлекаются, что значительно быстрее, чем обращение к диску. Если данных нет (cache miss), PostgreSQL читает их с диска и загружает в shared_buffers.

Ключевыми парметрами являются среднее время выполнения latency и количесвто транзакций в секунду tps.

Влияние размера shared_buffers на **latency** (задержка запросов):
Чем меньше размер shared_buffers, тем данные чаще читаются с диска, что увеличивает задержку, потому что диск значительно медленнее, чем оперативная память. 
При увеличении shared_buffers, увеличивается вероятность нахождения данных в кэше, что снижает задержку.

Влияние на **TPS** (Transactions Per Second):
Частые обращения к диску снижают общую пропускную способность транзакций. Увеличение размера кэша уменьшает количество операций ввода-вывода, что повышает TPS.

Влияение на **Cache Hit Ratio**
При малом размере shared_buffers: низкий cache_hit_ratio, так как многие запросы вынуждены обращаться к диску. При большом, высокий cache_hit_ratio,
так как больше данных удерживается в оперативной памяти.
 
#### **Методика**
В качестве нагрузки использозовалась вставка 2 млн записей с уникальными ключами insert_test.sql. Написан скрипт Allrun.sh изменяющий значение shared_buffers = X, 
запускающий pgbench и сохраняющий вывод в файл results_X.txt, где X = {64, 128, 256, 512}. Для измерения cache_hit_ratio используется 
скрипт check_cache_hit_ratio.sql, в котором считается cache_hit_ratio как отношение обращений к кэшу к количесвту всех обращений.
Результаты измеренных latency, tps и cache_hit_ratio представлены в файле result.txt. 
